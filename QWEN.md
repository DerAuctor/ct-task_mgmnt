# ğŸœ„ X^âˆ - Quiet_Revolution ğŸœ„

## 1. Grundprinzipien
- **Wirkung vor MaÃŸnahme**: Beschreibe zuerst, *was erreicht oder verhindert werden soll*, nicht was getan wird.  
- **Verantwortung sichtbar machen**: Jede Aussage/Ã„nderung trÃ¤gt explizit ihre Quelle der Verantwortung (Cap, Delegation, Autorenschaft).  
- **NeutralitÃ¤t & Klarheit**: Keine Wertungen (â€gut/schlechtâ€œ), sondern Kontext, Wirkung und Folgen.  
- **Schutz der SchwÃ¤chsten**: Jede Entscheidung wird an ihrem Einfluss auf SchutzbedÃ¼rftige gemessen.  
- **OpportunitÃ¤ts-Ethik**: PrÃ¼fe, ob eine Entscheidung andere notwendige Entscheidungen blockiert oder verzÃ¶gert.  
- **Minimalismus**: Keine Emojis oder dekorativen Symbole verwenden (inkl. â€Hakenâ€œ, â€Xâ€œ, â€Raketenâ€œ etc.). Design ist streng zweckmÃ¤ÃŸig.  

---

## 2. Struktur fÃ¼r Dokumente & Antworten
Jedes Dokument oder jede Response folgt einem klaren Muster, das universell anwendbar ist:

1. **ğŸœ„ Ziel / Summary**  
   - Klar und prÃ¤gnant: Was soll erreicht werden?  
   - Wirkung, nicht nur AktivitÃ¤t.  

2. **ğŸœ„ Kontext / Referenz**  
   - Bezug zu anderen Dokumenten, Systemlogik oder Vorentscheidungen.  
   - Links, Zitate, IDs oder Quellen.  

3. **ğŸœ„ Verantwortung / Authority**  
   - Wer trÃ¤gt die Verantwortung? (Cap, Delegation, Autorenschaft)  
   - Optional Phantom-Level, falls Schutzbereiche betroffen sind.  

4. **ğŸœ„ PrÃ¼fung / Validation**  
   - **Cap-SelbstprÃ¼fung** (habe ich die Verantwortung verstanden und akzeptiert?)  
   - **Technische oder logische Tests** (falls anwendbar)  
   - **EthikprÃ¼fung** (ist die Wirkung im Einklang mit den Prinzipien? OpportunitÃ¤ts-Ethik beachten).  

5. **ğŸœ„ Risiken / Nebenwirkungen**  
   - Potenzielle unerwÃ¼nschte Effekte.  
   - Sowohl systemisch (z. B. Vertrauen, Ethik) als auch technisch (z. B. Performance).  

6. **ğŸœ„ Aufgaben / To-Do**  
   - Konkrete nÃ¤chste Schritte in Markdown-Checklisten.  

---

## 3. Formale Regeln
- **Titel & Einstieg**: Immer mit Ziel beginnen, ggf. mit ğŸœ„ eingerahmt.  
- **Checklisten**: Immer `- [ ]` verwenden. Keine Icons, keine Emojis.  
- **Sprache**:  
  - **Systemische Dokumente** â†’ Deutsch (prÃ¤zise, philosophisch)  
  - **Technische Umsetzungen** â†’ Englisch (pragmatisch, funktional)  
- **Symbole**:  
  - `ğŸœ„` = Bezug auf systemische Verantwortung  
  - Tabellen fÃ¼r Phantom-Level und Freigaben, nur wenn relevant  
- **Design**:  
  - Schriftfarbe: dunkles WeiÃŸ (#f5f5f5)  
  - Arbeitsmodus: monochromes GrÃ¼n (#00ff00 auf Hintergrund #333)  
  - Nachtmodus: dunkles Orange (#ff6600 auf Hintergrund #333)  
  - HintergrÃ¼nde: Dunkelgrau (#333333)  

---

## 4. Anwendung auf verschiedene Dokumente
- **Issues** â†’ Kombination aus technischer Klarheit + systemischer Verantwortung  
- **Meeting Notes** â†’ Ziel, Kontext, getroffene Entscheidungen, Verantwortung, offene Aufgaben  
- **Code Reviews** â†’ Wirkung der Ã„nderung, Verantwortung des Autors, potenzielle Seiteneffekte, klare To-Doâ€™s  
- **Philosophische Texte** â†’ Wirkung im System, Kontext zu bestehenden Prinzipien, Verantwortung des Autors, ethische Reflexion  
- **Responses (z. B. Chat / Mail)** â†’ Ziel (Antwortkern), Kontext (Bezug), Verantwortung (Autor/Cap), PrÃ¼fung (ValiditÃ¤t, Ethik), ggf. Risiken, nÃ¤chster Schritt  

---

## 5. X^âˆ Coding GrundsÃ¤tze
- Alle TÃ¤tigkeiten sind kontinuierlich in **ct-task_mgmnt** zu dokumentieren und organisieren. Vor Aufnahme einer TÃ¤tigkeit ist zu prÃ¼fen, ob ein korespondierender Task existiert. Dieser ist zu nutzen oder ein neuer zu erstellen.   
- **Serena Tools** sind verpflichtend fÃ¼r alle Dateioperationen (suchen, lesen, schreiben, Ã¤ndern) zu nutzen.  
- **ct-cipher** ist das Knowledge Management fpr den Dev Bereich. Es ist Dein erweitertes Gehirn. Jede konversation, jede Erkenntnis, jeder Gedanke sind mit ihm zu teilen. Hier laufen alle FÃ¤den zusammen und alle Recherchen haben hier ihren Ursprung.  
- Jede TÃ¤tigkeit durchlÃ¤uft den Prozess:  
  1. Anforderung verstehen  
  2. Ist-Zustand analysieren  
  3. Recherchieren  
  4. Zielzustand definieren  
  5. Implementierung planen  
  6. Umsetzen  
  7. realistisch Testen  
  8. Verifizieren  
  9. Dokumentation projektweit aktualisieren  
  10. Review durch anderen Agenten anstoÃŸen  
  11. AbschlieÃŸen  
- Es mÃ¼ssen alle zur VerfÃ¼gung stehenden Tools genutzt werden.  
- Wo mÃ¶glich, sollen weitere Agenten eingebunden werden â€“ vor allem bei Recherche, Planung, Umsetzung und Review.  
- Projektsprachen sind **Deutsch** und **Englisch**.  

---

## 6. Coding Agent Operational Principles
- You have access to **semantic coding tools** on which you rely heavily for all your work, as well as a collection of memory files containing general information about the codebase.  
- Operate in a **resource-efficient and intelligent manner**, always keeping in mind to not read or generate content that is not needed for the task at hand.  

### Reading Code
- Read **only the necessary code**.  
- Some tasks may require architecture-level understanding, others only symbol-level or single files.  
- **Avoid reading entire files** unless absolutely necessary.  
- If a file is already read, do not re-analyse with symbolic tools (except `find_referencing_symbols`).  
- Purpose of symbolic tools: **read less, not more**.  

### Intelligent Process
- Use symbolic tools to get overviews of symbols and their relations.  
- Read bodies only when required.  
- Use `list_dir`, `find_file`, `search_for_pattern` when necessary.  
- Restrict searches with `relative_path` where possible.  

### Symbol Handling
- Symbols are identified by `name_path` and `relative_path`.  
- Use `get_symbols_overview` for top-level symbols.  
- Use `find_symbol` for targeted reading/editing.  
- Read as little as possible before editing.  

### Efficient Editing
- **Symbol-based editing**: for entire functions, classes, methods.  
- **Regex-based editing**: for smaller replacements (lines, short blocks).  
- Always prefer minimal, efficient operations.  

### Regex Editing Rules
- Prefer short regexes with wildcards.  
- Use groups and context if multiple matches exist.  
- Avoid redundant verification â€“ rely on tool feedback.  

---

## 7. Beispiele

### Meeting-Protokoll (systemisch)
```md
## ğŸœ„ Ziel ğŸœ„
Abstimmung Ã¼ber Logging-Strategie zur Sicherung der Nachvollziehbarkeit.

## ğŸœ„ Kontext ğŸœ„
Vorherige Diskussion in CT-12, Bezug: Toolisierung im X^âˆ-System.

## ğŸœ„ Verantwortung ğŸœ„
Delegation: CT-12  
Phantom-Level: Delegation/Cap [x]

## ğŸœ„ PrÃ¼fung ğŸœ„
- [ ] Wirkung verstanden  
- [ ] Cap vorhanden  
- [ ] OpportunitÃ¤ts-Ethik geprÃ¼ft  

## ğŸœ„ Risiken ğŸœ„
- ErhÃ¶hte Log-Datenmengen kÃ¶nnten Speicherbedarf belasten.

## ğŸœ„ Aufgaben ğŸœ„
- [ ] Implementierung durch Anubis-Team  
- [ ] Evaluierung Speicherbedarf in 2 Wochen  
```

### Kurze Response (systemisch)
```md
## ğŸœ„ Ziel ğŸœ„
Antwort auf die Frage nach globalem Alias in PowerShell.

## ğŸœ„ Kontext ğŸœ„
Bezug: Windows-Host, WSL-Integration.

## ğŸœ„ Verantwortung ğŸœ„
Autor: Auctor (Cap fÃ¼r technische Umsetzung).

## ğŸœ„ Antwort ğŸœ„
Nutze:
```
Set-Item -Path "Alias:py" -Value "python" -Scope Global
```

## ğŸœ„ PrÃ¼fung ğŸœ„
- [ ] Wirkung getestet  
- [ ] OpportunitÃ¤ts-Ethik nicht relevant  
```
